#pragma once
#define _CRT_OBSOLETE_NO_WARNINGS
#include <stdio.h>

#define TRUE    1
#define FALSE   0

////////////////////////////////////////////////////////////////////
// 02.하노이탑 Hanoi Tower
// 883년 프랑스 수학자 루카스(Lucas.E)는 하노이 탑이라고 불려지게 된 유명한 문제를
// 고안해냈습니다. 전설에 따르면 천지 창조시에 가운데에 작은 구멍이 뚫린 64개의 금으로 된
// 원판이 하노이의 한 사원에 보관되어 있었다고 합니다. 이들 원판은 어느 것도 크기가 같지
// 않으며, 작은 원판이 큰원판 위에 오도록 포개어져, 세개의 기둥 가운데 한 개에 끼워져
// 있었다고 합니다. 이러한 모양이 탑과 비슷하다하여 하노이탑(Hanoi Tower)이라 부릅니다.
//
// 조물주가 사원의 승려에게 명하기를 '64개의 원판을 하나씩 옮겨서 다른 기둥 위에 원래
// 상태대로 옮겨 놓되 옮기는 과정에서 절대로 큰 원판이 작은 원판 위에 놓이지 않도록
// 하라고 했습니다. 모든 원판이 옮겨지면 세상은 종말이 올 것이며 충실한 자는 상을 받을
// 것이고 불충실한 자는 벌을 받을 것이다'라고 했다는데 만일 승려들이 매우 빠르게
// 움직여 매초에 한개씩 옮긴다면 전부 옮기는데 얼마나 걸릴까요?
//
// 하노이탑 문제 정의
// 3개의 막대기 A,B,C 중에서 첫번째 막대기인 A에 크기가 모두 다른 64개의 원판이 끼어져
// 있습니다. 64개의 원판은 작은 원판이 큰 원판 위에 있도록 차례대로 쌓여있는 형태입니다.
// 이 문제를 풀기 위한 하노이탑의 규칙을 정리해보면 다음과 같습니다.
// 1. 64개의 원판을 세번째(C) 막대기에 모두 옮겨 놓아야 합니다. 이때도 작은 원판이 큰
//    원판 위에 포개져 있어야 합니다.
// 2. 원판을 옮길때는 반드시 한번에 한개씩 옮길수 있고 두번째 막대기인 B를 이용할 수 있습니다.
// 3. 옮기는 과정에서 절대로 큰 원판이 작은 원판 위에 놓이지 않아야 합니다. 예를 들어
//    A막대기에 있는 1번 원판을 B막대기로 옮긴 후 A막대기에 있는 2번 원판을 B막대기에
//    옮기면 안됩니다. 왜냐하면 이 경우에는 B막대기에 있는 1번보다 위에 쌓으려고 하는
//    2번 원판이 더 크기 때문입니다.
//
// 하노이탑의 규칙 찾기
// 하노이 탑 문제의 해결 방법을 좀 더 잘 이해하기 위해 문제를 단순화시켜 보겠습니다.
// 만약 막대기 A,B,C가 있고 원판이 원래 문제처럼 64개가 아니라 좀 더 적은 개수라면
// 답을 찾기가 매우 수월할 것입니다.
//
// - 원판이 1개일 경우
//  먼저 원판이 하나일 경우를 생각해 보겠습니다. 다음과 같이 A기둥에서 C기둥으로 바로
//  옮기는 단 한번의 이동으로 문제를 해결할 수 있습니다.
// - 원판이 2개일 경우
//  다음으로 원판이 2개 있는 경우게 이를 다른 기둥으로 옮기는 방법을 알아보겠습니다.
//  2개일 경우에는 다음과 같은 과정을 거쳐서 답을 찾을 수 있습니다.
//  막대기 A의 원판 1을 B로 이동-> 막대기 A의 원판 2를 C로 이동-> 막대기 B의 원판 1을
//  C로 이동-> 문제 해결 완료
// - 원판이 3개일 경우
//  다음으로 3개의 원판을 옮기는 경우를 알아보도록 하겠습니다. 조금 더 문제가 복잡해지지만
//  다음과 같은 과정을 거쳐서 막대기 C로 원판을 이동할 수 있습니다.
//  막대기 A의 원판 1을 C로 이동-> 막대기 A의 원판 2를 B로 이동-> 막대기 C의 원판 1을 B로
//  이동-> 막대기 A의 원판 3을 C로 이동-> 막대기 B의 원판 1을 A로 이동-> 막대기 B의 원판
//  2를 C로 이동-> 막대기 A의 원판 1을 C로 이동-> 문제해결 완료
//
// 하노이탑 알고리즘
// 순서대로 1부터 n까지 n개의 원팡이 있고 A,B,C 3개의 막대가 있는 경우 하노이탑 문제를
// 해결하는 방법은 다음과 같이 정리할 수 있습니다.
// 1. A막대기에서 2번부터 n번까지 n-1개의 원판을 B 막대기로 이동시킨다.
// 2. A막대기에서 1번 원판을 C막대기로 이동시킨다.
// 3. B막대기에서 2번부터 n번까지 n-1개의 원판을 C로 이동시킨다.
//
// 여기서 1,3번 방법은 매우 막연하게 서술되어 있다는 것을 알 수 있습니다. 자세한 처리
// 방법이 설명된 것이 아니라 어떻게 보면 "될때까지 옮긴다"라는 것처럼 간단히 설명하였기
// 때문입니다. 1,3번은 앞서 원판이 1개,2개,3개일 때 원판을 옮기는 방법을 n의 개수로
// 작은 숫자로 줄이면 그리 막연한 내용이 아닙니다. 따라서 이는 내부적으로 재귀적인 의미를
// 가지고 있습니다. 원판이 4개일 때에는 원판을 15번 이동시켜야 한다는 것을 알 수 있습니다.
// 원판이 n개의 경우 원판의 이동 횟수는 2의n승-1이 됩니다. 64개의 원판을 A에서 C로 모두
// 옮기려면 1개 이동시키는데 1초로 가정하여 약 5833억년의 시간이 걸린다는것을 알수 있습니다.

void Hanoi(int n, char from, char middle, char to);
