#pragma once
#define _CRT_OBSOLETE_NO_WARNINGS
#include <stdio.h>
#include <malloc.h>

#define TRUE    1
#define FALSE   0

typedef struct SingleNode
{
	struct SingleNode* pNext;
	int nData;
}SingleNode;

typedef struct DoubleNode
{
	struct DoubleNode* pPrev;
	struct DoubleNode* pNext;
	int nData;
}DoubleNode;

////////////////////////////////////////////////////////////////////
// 06. 링크 Link
// 배열의 한계점
// 배열은 배열 내의 특정 요소에 접근할때 시작 주소로부터 얼만큼의 거리에 있는지를
// 의미하는 오프셋(offset)을 계산하여 직접 접근하게 되므로 매우 빠른 속도로 데이터를
// 접근할 수 있습니다. 그리고 첨자나 포인터 연산을 이용해서 비교적 쉬운 방법으로
// 많은 수의 데이터를 다룰 수 있는 장점이 있습니다. 하지만 배열을 이용해서 데이터를
// 다루는 데에는 아래와 같은 한계점이 있습니다.
// 1. 메모리 사용이 비효율적이다.
//    배열은 정적인 자료구조입니다. 즉 배열의 선언 시점에 배열의 크기가 정해지는데
//    이를 위해선 배열에 얼만큼의 데이터가 저장될 것인지 미리 알고 있어야 합니다.
//    선언된 이후에는 배열의 크기를 다시 늘리거나 줄이거나 하는 작업이 허용되지
//    않으므로 최초 선언된 배열의 크기를 넘어서면 더이상의 데이터를 저장할수 없게
//    됩니다. 따라서 배열을 선언할 때에는 저장될 것으로 예상되는 최대개수를 예상해서
//    할당하게 됩니다.
// 2. 배열내의 데이터 이동 및 재구성이 어렵다.
//    최대 크기로 배열을 선언해야 한다는 것은 메모리 측면에서는 매우 비효율적입니다.
//    예를 들어 100개의 데이터가 저장될 것으로 예상하고 배열을 선언했는데 실제 10개의
//    데이터만 사용되고 있다면 나머지 90개의 저장 공간은 낭비되고 있는 것입니다.
//    또한 배열은 메모리 상에서 순차적으로 존재하게 됩니다. 일렬로 이어진 형태로 각 요소
//    들이 배열의 시작부터 끝까지 이어지는데 만약 배열의 중간에 위치한 요소를 삭제한다면
//    그 이후에 있는 배열 요소를 모두 하나씩 위치를 옮겨와야 하는 문제가 발생합니다.
//    또는 배열의 특정 위치에 데이터를 삽입해야 한다면 원래 있던 데이터의 위치를 모두
//    뒤로 옮겨야하는 문제도 발생합니다. 즉 배열내의 데이터를 이동하고 재구성하는데
//    많은 작업을 필요로 하게 됩니다.
//
// 연결 리스트란?
// 위의 한계점 때문에 배열은 많은 수의 다양한 데이터를 처리하는 데에는 적합하지 않습니다.
// 실제 데이터를 처리하기 위해 다양한 알고리즘을 이용한 스택, 트리, 그래프, 큐, 해시 등의
// 자료 구조가 실무에서 사용되는데 여기서는 가장 기본이 되는 연결 리스트('Linked List')에
// 대하여 알아보도록 하겠습니다. 연결 리스트는 다음 노드의 위치를 앞 노드가 가리키고
// 있으므로 순차적으로 존재할 필요가 없습니다. 또한 배열은 그 크기가 미리 정해진 정적인
// 자료구조임에 반해 연결 리스트는 실행시에 동적으로 구성할수 있다는 점에서 메모리를
// 보다 효율적으로 이용할 수 있습니다. 하지만 구성하고 있는 데이터를 탐색하는 속도는
// 순차적으로 접근할 수 있는 배열보다 느립니다. 연결리스트는 이를 구성하는 요소들이 다음
// 요소의 위치를 가리키며 줄줄이 연결되어 있습니다.여기서 이를 구성하는 하나의 요소를
// 노드('node')라고 합니다. 즉 노드들이 서로 연결되어 있는 구조가 바로 연결 리스트
// 입니다. 각 노드는 자신의 다음 노드 또는 이전 노드에 대한 위치를 기억하고 있는데 이를
// 링크('link')라고 합니다.
// _______________   _______________   _______________
// | Data | link---->| Data | link---->| Data | link | <- 꼬리노드(null)
// ---------------   ---------------   ---------------
//
// 연결 리스트와 배열의 비교
// 배열과 비교하여 연결 리스트의 장점
// 1. 메모리를 효율적으로 사용합니다.
//    실행 시에 필요한만큼 메모리를 할당하여 사용하고 제거할 수 있으므로 배열처럼
//    유휴공간이 발생하지 않아 효율적입니다.
// 2. 데이터 재구성이 용이합니다.
//    내부 데이터를 정렬하는 경우에도 배열처럼 실제 데이터를 이동하는 절차없이 링크의
//    변경만으로 데이터를 재구성할 수 있습니다.
// 3. 대용량 데이터를 처리하는데 적합합니다.
//    실제 메모리에서 사용 가능한 범위만큼의 데이터를 저장할 수 있으므로 대용량 데이터를
//    다루는데 적합합니다.
//
// 배열과 비교하여 연결 리스트의 단점
// 1. 데이터 탐색 속도가 느리다.
//    배열의 경우 메모리상에 연속적으로 존재하므로 오프셋을 이용한 포인터 연산으로 특정
//    요서에 직접 접근이 가능하지만 연결 리스트의 경우 머리노드에서부터 링크가 가리키는
//    위치의 노드를 순차적으로 탐색해야 하므로 상대적으로 느립니다.
// 2. 구현 및 사용 방법이 까다롭다.
//    동적 메모리의 할당 및 해제를 사용한 노드의 추가/삭제 및 데이터 탐색의 구현과
//    데이터를 구성하는 방법이 배열보다는 까다롭습니다.
//
// 연결 리스트의 종류
// 연결 리스트는 노드를 구성하는 링크의 개수나 노드를 구성하는 방식에 따라 단순 연결 리스트
// (Simple Linked List), 이중 연결 리스트(Double Linked List), 환형 연결 리스트
// (Circular Linked List)로 나뉩니다.
// 단순 연결 리스트는 다음 노드에 대한 링크만 가지는 연결리스트입니다. 다음 노드에 대한
// 정보만 가지고 있으므로 데이터 탐색시 앞방향으로만 전진(forward only)할 수 있습니다.
// 이중 연결 리스트는 다음 노드 뿐만 아니라 이전 노드에 대한 링크를 포함하는 연결 리스트
// 입니다. 따라서 단순 연결 리스트와는 달리 데이터 탐색시 뒷방향으로 후진(reward) 탐색도
// 가능합니다. 이전 노드에 대한 링크 정보를 저장할 공간이 추가적으로 필요하므로 단순 연결
// 리스트보다는 메모리 사용량이 상대적으로 많습니다.
//                 ____________________   ____________________   ____________________
// 머리노드(null)->link | Data | link |<->link | Data | link l<->link | Data | link | <-꼬리노드(null)
//                 --------------------   --------------------   --------------------
// 환형 연결 리스트는 마지막 노드의 링크가 머리 노드를 가리키는 연결 리스트 입니다. 즉,
// 머리노드만 있고 꼬리 노드가 없는 형태입니다. 마지막 노드가 머리 노드를 가리키므로
// 그 모양이 원 모약과 비슷하다고 해서 붙혀진 이름입니다.
//           _______________   _______________   _______________
// 머리노드->| Data | link---->| Data | link---->| Data | link | <- 머리노드 가리킴
//           ---------------   ---------------   ---------------
//

void LinkedList();
void singleInsertNode(SingleNode *pPrev, int nData);
void singleDeleteNode(SingleNode* pPrev);
void singleTraverseNode(SingleNode* pNode);

void doubleInsertNode(DoubleNode* pTarget, int nData);
void doubleDeleteNode(DoubleNode* pTarget);
void doubleTraverseNodeForward(DoubleNode* pNode);
void doubleTraverseNodeReverse(DoubleNode* pNode);

////////////////////////////////////////////////////////////////////
// 메모리 동적 할당과 해재
//
// 함수형식										설명
// void * malloc (size_t size)				size만큼 힙영역에 공간 할당하고 할당된 주소를 리턴
// void * colloc (size_t num, size_t size)	size만큼 메모리를 num만큼 할당하고 0으로 초기화, 영역 주소를 리턴
// void free ( void *memblock)				동적으로 할당된 영역인 memblock을 초기화하고 할당된 영역의 주소를 리턴
//
// malloc은 지정된 크기만큼 메모리의 힙(heap)영역에서 공간을 할당만 해줍니다.
// 반면 alloc은 필요한 공간을 할당하고 해당 영역을 모두 0으로 초기화까지 해줍니다.
//
// ex> int *pInt = (int *)malloc(sizeof(int));	// 4Byte 동적 할당
//     *pInt = 10;								// 동적 할당된 공간에 값으로 10을 저장
//     free(pInt);								// 메모리 해제
