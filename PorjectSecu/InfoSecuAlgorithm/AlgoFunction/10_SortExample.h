#pragma once
#define _CRT_OBSOLETE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <stdbool.h>

#define MAX_DIGIT	3
#define RADIX_SIZE	10

typedef struct strNode
{
	int nKey[MAX_DIGIT];
	struct strNode* pNext;
}NODE, *PNODE;

#define TRUE    1
#define FALSE   0

////////////////////////////////////////////////////////////////////
// 10. 정렬 Sorting
// 정렬(Sort)이란 임의의 순서로 구성되어 있는 다수의 자료를 일정한 순서로 재배열하는
// 것을 의미합니다. 일상생활 속에서도 정렬은 매우 흔히 사용되는것을 확인할 수 있는데
// 예를 들면 동호회나 어떤 모임의 주소록을 작성함에 있어서 회원이름을 가나다 순서로
// 정렬한다든지 학교에서 학기초에 학생들의 키 순서로 번호를 지정하기 위해서 일렬로
// 세우는 과정 등이 있습니다. 아무런 기준없이 흩어져 있는 데이터를 일정한 기준으로
// 재벼열하는 정렬에는 많은 알고리즘이 있으며 데이터의 특성에 따라 다양한 정렬 속도와
// 결과를 보여줍니다. 따라서 최적의 정렬 알고리즘은 정해져 있는 것이 아니며 상황에
// 가장 알맞은 알고리즘을 선택해야 합니다. 정렬은 다수의 데이터 중에서 두개의 데이터를
// 특정 기준으로 서로 비교하여 필요한 경우 위치를 교환하는 과정으로 진행됩니다.
// 얼마나 많은 비교를 하고 데이터를 교환하느냐에 따라 해당 검색 알고리즘의 정렬 속도와
// 필요한 저장 공간의 크기가 결정됩니다.
//
//
// [i]선택 정렬(Selection Sort)이란
// 선택정렬은 비교를 통해 작은 항목부터 찾아 정렬하는 방법입니다. 우선 첫번째 항목의
// 내용과 나머지 모든 항목을 비교하며 위치를 교환하여 가장 작은 항목이 앞으로 오도록
// 합니다. 그 다음은 두번째 항목이 비교대상이 되어 뒤의 항목들과 비교한후 작은 항목이
// 두번째에 위치하게 됩니다. 결국 가장 작은 항목부터 정렬이 이루어지게 됩니다.
// 기준 자료와 비교 자료들간의 대소 관계만 알수 있기 때문에 원시 자료가 정렬된 상태로
// 입력되오 있을 경우에도 O(n2[제곱])의 시간 복잡도가 요구됩니다. 그러나 최악의 경우나
// 최선의 경우 모두 O(n2[제곱])가 되어 알고리즘이 단순하다는 장접이 있습니다.
//
// 선택 정렬 알고리즘 규칙
// 1. 가장 작은 수를 앞으로 보내기 위해 첫번째 항목부터 기준이 됩니다.
// 2. 1번 항목을 첫번째 항목부터 마지막 항목 직전까지 반복해서 적용합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//	3	5	8	4	7
//	
//	3	5	8	4	7
//	3	4	8	5	7
//
//	3	4	8	5	7
//	3	4	5	8	7
//
//	3	4	5	8	7
//	3	4	5	7	8
// 
// 개선된 선택 정렬 알고리즘
// 기본 알고리즘에 하나의 인덱스 변수를 더 사용하여 데이터 교환 횟수를 최소화 할 수
// 있습니다. 즉, 한 회전에서 최소값을 가진 위치를 기억하여 대상 데이터들 중 가장
// 앞의 데이터와 교환하는 방법입니다.
//
//
// [ii] 버블 정렬(Bubble Sort)이란
// 거품정렬이라고도 하는 버블 정렬은 인접한 레코드 2개의 파일을 비교해서 크기에 따라
// 레코드 위치를 상호 교환하는 방식으로 진행됩니다. 선택정렬은 작은 항목부터 정렬되는
// 방법이지만 버블정렬은 큰 항목부터 정렬이 이루어집니다. 거품정렬은 정렬방법이
// 간단하여 실무에서 많이 사용되고 있지만 수행시간이 늦다는 단점이 있습니다.
//
// 버블 정렬 알고리즘 규칙
// 1. 첫번째 데이터부터 마지막 데이터 바로 앞의 데이터까지 아래 2번 항목을 반복합니다.
// 2. 첫번째 데이터부터 지정된 마지막 데이터까지 인접한 항목과 비교하며 뒤에 큰수가
//    오도록 데이터를 교환합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//	4	5	3	8	7
//	4	5	3	7	8
//
//	4	5	3	7	8
//	4	3	5	7	8
//
//	4	3	5	7	8
//	3	4	5	7	8
//
//	3	4	5	7	8
//	3	4	5	7	8
//
// 개선된 버블 정렬 알고리즘
// 비교 대상의 제한 : 한 회전마다 인덱스의 끝까지 비교하지 않고 이전 회전에서 마지막
//                    변경이 발생했던 위치까지만 비교하도록 합니다.
// 종료 조건 : 변경이 발생하지 않았다면 모두 정렬이 끝난 상태이므로 플래그 값을
//             이용하여 이를 판단하여 정렬을 중단하도록 합니다.
//
//
// [iii] 삽입 정렬(Insertion Sort)이란
// 삽입정렬은 이미 정렬되어 있는 파일에 새로운 항목을 삽입하는 방식으로 삽입된 항목의
// 위치를 찾아주는 방법입니다. 한 개의 레코드로부터 시작해서 차례대로 삽입되며 별도의
// 저장 공간이 필요하지 않는 장점이 있습니다.
//
// 삽입 정렬 알고리즘 규칙
// 1. 두번째 데이터부터 마지막 데이터까지 아래의 과정을 반복합니다.
// 2. 기준 데이터 앞은 이미 정렬된 상태이며 기준 데이터를 정렬된 리스트에 삽입하는
//    것이 핵심입니다. 이때 기준 데이터를 특별한 변수에 저장해 놓습니다.
// 3. 정렬된 리스트의 내용과 기준 데이터를 하나씩 비교하며 기준 데이터보다 크다면
//    한자리씩 뒤로 밀어줍니다.
// 4. 만약 기준 데이터보다 작은 항목이 나타나면 자리 밀기를 정지하고 빈 위치에
//    저장되어 있는 기준 데이터를 삽입합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//
//	4	5	8	3	7
//
//	4	5	8	3	7
//	4	5	3	8	7
//	4	3	5	8	7
//	3	4	5	8	7
//
//	3	4	5	8	7
//	3	4	5	7	8
//
//
// [iv] 쉘 정렬(Shell Sort)이란
// 쉘정렬은 삽입정렬의 확장으로 생각해도 됩니다. 일정한 간격에 위치한 항목들 간에
// 삽입 정렬을 하는 것으로 입력 파일이 부분적으로 정렬된 경우 유리한 알고리즘입니다.
//
// 쉘 정렬 알고리즘 규칙
// 1. Knuth에 의한 간격을 결정합니다.이때 총 데이터 개수를 고려하여 결정해야 됩니다.
// 2. 간격을 3으로 나눠가며 다음 알고리즘을 반복합니다. 3으로 나누는 이유는 Knuth에
//    의한 다음 간격을 구하기 위해서 입니다. 예를 들어 처음이 13으로 시작했다면 다음
//    회전은 간격이 4가 되며 마지막 회전의 간격은 1이 됩니다.
// 3. 결정된 간격만큼 떨어진 데이터들에 대한 삽입 정력을 수행합니다.
// ex>
// 쉘 정렬은 일정한 간격에 있는 항목들간 비교가 이루어져야 하며 이때 간격을 정하는
// 방식으로 다음과 같은 세가지 정도를 생각할 수 있습니다.
// 1) 전체 데이터의 개수를 2로 나누어가며 간격을 정하는 방법
//    데이터 개수 12
//    1회전-> 12/2 = 6 (6만큼 떨어진 항목들간 삽입 정렬을 시행함)
//    2회전-> 6/2 = 3
//    3회전-> 3/2 = 1
// 2) Knuth의 개선된 알고리즘을 통해 간격을 정하는 방법
//    간격 h는 아래의 공식에 따라 구할 수 있습니다.
//    h = 3 * h + 1
//    h = {1, 4, 13. 40, 121, 363...}
//    실제 적용할 때에는 전체 데이터 개수보다 작은 수를 선택하여 간격이 1이 될때까지
//    좁혀가면서 삽입정렬을 수행합니다.
// 3) 임의로 간격을 정하는 방법
//    여기에는 Knuth알고리즘을 이용해서 쉘 정렬하는 과정을 알아보도록 하겠습니다.
//	19	13	05	27	01	26	31	16	02	09	11	21
//
// ~~@..@~~ 쉘정렬은 조금 더 확인이 필요 //////////////////////////////////////////////
// ~~@..@~~ 쉘정렬은 조금 더 확인이 필요 //////////////////////////////////////////////
//
//
// [v] 퀵 정렬(Quick Sort)이란
// 퀵정렬은 제어키(pivot)를 중심으로 제어키보다 큰 값은 제어키의 오른쪽에, 제어키보다
// 작은값은 제어키의 왼쪽으로 이동하는 정렬 방식입니다. 평균 수행 능력이 상당히
// 뛰어나며 폭넓게 사용되고 있습니다.
//
// 퀵 정렬 알고리즘 규칙
// 1. 맨 앞의 수를 제어키로 정합니다.
// 2. 제어키를 제외한 항목 중 앞에서부터 각 항목과 제어키를 비교하여 제어키보다
//    클 경우 정지합니다. 이와 동시에 항목의 뒤에서부터 각 항목과 제어키를 비교하여
//    제어키보다 작을 경우 정지합니다.
// 3. 정지된 상태에서 해당 인덱스의 두 수를 교환한 후 두 수가 교차할 때까지
//    양방향으로 계속 진행합니다.
// 4. 앞에서 진행되는 인덱스와 뒤에서 진행되는 인덱스가 교차할 경우 제어키와의 교환이
//    이루어지는데 이때 뒤에서 진행되던 인덱스의 항목과 제어키를 교환합니다.
//    제어키의 위치가 정해지며 제어키를 중심으로 양쪽 항목들에 대해 각각 퀵 정렬을
//    수행합니다. 퀵 정렬은 재귀호출을 사용하는 순환 프로그램으로 구현되며
//    스택 자료구조를 이용합니다.
// ex>
//			   value				down	up		pivot
// 26 05 37 01 61 11 59 15 48 19	1		10		26
// 11 05 19 01 15 26 59 61 48 37	1		5		11
// 01 05 11 19 15 26 59 61 48 37	1		2		1
// 01 05 11 19 15 26 59 61 48 37	4		5		19
// 01 05 11 15 19 26 59 61 48 37	7		10		59
// 01 05 11 15 19 26 48 37 59 61	7		8		61
// 01 05 11 15 19 26 37 48 59 61	10		10		61
// 01 05 11 15 19 26 37 48 59 61	Result
//
//
// [vi] 힙 정렬(Heap Sort)이란
// 힙 정렬은 최대 히프 트리나 최소 히프 트리를 만들어서 정렬을 하는 방법입니다. 즉
// 오름차순 정렬을 위해서는 최대 힙을 구성해야하고, 내림차순 정렬을 위해서는 최소 힙을
// 구성해야 합니다. 최대 힙을 이용한 정렬 방법이나 최소 힙을 이용한 정렬 방법의 원리는
// 동일하므로 여기에서는 최대 힙을 통한 오름차순 정렬만 알아보도록 하겠습니다.
//
// ~~@..@~~ 힙정렬은 조금 더 확인이 필요 //////////////////////////////////////////////
// ~~@..@~~ 힙정렬은 조금 더 확인이 필요 //////////////////////////////////////////////
//
// [vii] 병합 정렬(Merge Sort)이란
// [viii] 기수 정렬(Radix Sort)이란
//

void SelectionSort(int data[], int n);
void BubbleSort(int data[], int n);
void InsertionSort(int data[], int n);
void ShellSort(int data[], int n);
void QuickSort(int data[], int n);
void Reheap(int data[], int i, int n);		// Heap
void HeapSort(int data[], int n);			// Heap
void MergeSort(int data1[], int data2[], int m, int n);

PNODE RadixSort(PNODE pNode);				// Radix
void AddToList(PNODE pHead, PNODE pNode);	// Radix
void DeleteList(PNODE pNode);				// Radix
void PrintList(PNODE pNode);				// Radix

void PrintArray(int data[], int n);			// Common Output Function
void SortBasic();							// Common Main Function