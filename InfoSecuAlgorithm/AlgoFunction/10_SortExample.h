#pragma once
#define _CRT_OBSOLETE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>

#define TRUE    1
#define FALSE   0

////////////////////////////////////////////////////////////////////
// 10. 정렬 Sorting
// 정렬(Sort)이란 임의의 순서로 구성되어 있는 다수의 자료를 일정한 순서로 재배열하는
// 것을 의미합니다. 일상생활 속에서도 정렬은 매우 흔히 사용되는것을 확인할 수 있는데
// 예를 들면 동호회나 어떤 모임의 주소록을 작성함에 있어서 회원이름을 가나다 순서로
// 정렬한다든지 학교에서 학기초에 학생들의 키 순서로 번호를 지정하기 위해서 일렬로
// 세우는 과정 등이 있습니다. 아무런 기준없이 흩어져 있는 데이터를 일정한 기준으로
// 재벼열하는 정렬에는 많은 알고리즘이 있으며 데이터의 특성에 따라 다양한 정렬 속도와
// 결과를 보여줍니다. 따라서 최적의 정렬 알고리즘은 정해져 있는 것이 아니며 상황에
// 가장 알맞은 알고리즘을 선택해야 합니다. 정렬은 다수의 데이터 중에서 두개의 데이터를
// 특정 기준으로 서로 비교하여 필요한 경우 위치를 교환하는 과정으로 진행됩니다.
// 얼마나 많은 비교를 하고 데이터를 교환하느냐에 따라 해당 검색 알고리즘의 정렬 속도와
// 필요한 저장 공간의 크기가 결정됩니다.
//
// [i]선택 정렬(Selection Sort)이란
// 선택정렬은 비교를 통해 작은 항목부터 찾아 정렬하는 방법입니다. 우선 첫번째 항목의
// 내용과 나머지 모든 항목을 비교하며 위치를 교환하여 가장 작은 항목이 앞으로 오도록
// 합니다. 그 다음은 두번째 항목이 비교대상이 되어 뒤의 항목들과 비교한후 작은 항목이
// 두번째에 위치하게 됩니다. 결국 가장 작은 항목부터 정렬이 이루어지게 됩니다.
// 기준 자료와 비교 자료들간의 대소 관계만 알수 있기 때문에 원시 자료가 정렬된 상태로
// 입력되오 있을 경우에도 O(n2[제곱])의 시간 복잡도가 요구됩니다. 그러나 최악의 경우나
// 최선의 경우 모두 O(n2[제곱])가 되어 알고리즘이 단순하다는 장접이 있습니다.
// 선택 정렬 알고리즘 규칙
// 1. 가장 작은 수를 앞으로 보내기 위해 첫번째 항목부터 기준이 됩니다.
// 2. 1번 항목을 첫번째 항목부터 마지막 항목 직전까지 반복해서 적용합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//	3	5	8	4	7
//	
//	3	5	8	4	7
//	3	4	8	5	7
//
//	3	4	8	5	7
//	3	4	5	8	7
//
//	3	4	5	8	7
//	3	4	5	7	8
// 
// 개선된 선택 정렬 알고리즘
// 기본 알고리즘에 하나의 인덱스 변수를 더 사용하여 데이터 교환 횟수를 최소화 할 수
// 있습니다. 즉, 한 회전에서 최소값을 가진 위치를 기억하여 대상 데이터들 중 가장
// 앞의 데이터와 교환하는 방법입니다.
//
// [ii] 버블 정렬(Bubble Sort)이란
// 거품정렬이라고도 하는 버블 정렬은 인접한 레코드 2개의 파일을 비교해서 크기에 따라
// 레코드 위치를 상호 교환하는 방식으로 진행됩니다. 선택정렬은 작은 항목부터 정렬되는
// 방법이지만 버블정렬은 큰 항목부터 정렬이 이루어집니다. 거품정렬은 정렬방법이
// 간단하여 실무에서 많이 사용되고 있지만 수행시간이 늦다는 단점이 있습니다.
// 버블 정렬 알고리즘 규칙
// 1. 첫번째 데이터부터 마지막 데이터 바로 앞의 데이터까지 아래 2번 항목을 반복합니다.
// 2. 첫번째 데이터부터 지정된 마지막 데이터까지 인접한 항목과 비교하며 뒤에 큰수가
//    오도록 데이터를 교환합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//	4	5	3	8	7
//	4	5	3	7	8
//
//	4	5	3	7	8
//	4	3	5	7	8
//
//	4	3	5	7	8
//	3	4	5	7	8
//
//	3	4	5	7	8
//	3	4	5	7	8
//
// 개선된 버블 정렬 알고리즘
// 비교 대상의 제한 : 한 회전마다 인덱스의 끝까지 비교하지 않고 이전 회전에서 마지막
//                    변경이 발생했던 위치까지만 비교하도록 합니다.
// 종료 조건 : 변경이 발생하지 않았다면 모두 정렬이 끝난 상태이므로 플래그 값을
//             이용하여 이를 판단하여 정렬을 중단하도록 합니다.
//
// [iii] 삽입 정렬(Insertion Sort)이란
// 삽입정렬은 이미 정렬되어 있는 파일에 새로운 항목을 삽입하는 방식으로 삽입된 항목의
// 위치를 찾아주는 방법입니다. 한 개의 레코드로부터 시작해서 차례대로 삽입되며 별도의
// 저장 공간이 필요하지 않는 장점이 있습니다.
// 삽입 정렬 알고리즘 규칙
// 1. 두번째 데이터부터 마지막 데이터까지 아래의 과정을 반복합니다.
// 2. 기준 데이터 앞은 이미 정렬된 상태이며 기준 데이터를 정렬된 리스트에 삽입하는
//    것이 핵심입니다. 이때 기준 데이터를 특별한 변수에 저장해 놓습니다.
// 3. 정렬된 리스트의 내용과 기준 데이터를 하나씩 비교하며 기준 데이터보다 크다면
//    한자리씩 뒤로 밀어줍니다.
// 4. 만약 기준 데이터보다 작은 항목이 나타나면 자리 밀기를 정지하고 빈 위치에
//    저장되어 있는 기준 데이터를 삽입합니다.
// ex>
//	5	4	8	3	7
//	4	5	8	3	7
//
//	4	5	8	3	7
//
//	4	5	8	3	7
//	4	5	3	8	7
//	4	3	5	8	7
//	3	4	5	8	7
//
//	3	4	5	8	7
//	3	4	5	7	8
//
// [iv] 쉘 정렬(Shell Sort)이란
// 쉘정렬은 삽입정렬의 확장으로 생각해도 됩니다. 일정한 간격에 위치한 항목들 간에
// 삽입 정렬을 하는 것으로 입력 파일이 부분적으로 정렬된 경우 유리한 알고리즘입니다.
// 쉘 정렬 알고리즘 규칙
// 1. Knuth에 의한 간격을 결정합니다.이때 총 데이터 개수를 고려하여 결정해야 됩니다.
// 2. 간격을 3으로 나눠가며 다음 알고리즘을 반복합니다. 3으로 나누는 이유는 Knuth에
//    의한 다음 간격을 구하기 위해서 입니다. 예를 들어 처음이 13으로 시작했다면 다음
//    회전은 간격이 4가 되며 마지막 회전의 간격은 1이 됩니다.
// 3. 결정된 간격만큼 떨어진 데이터들에 대한 삽입 정력을 수행합니다.
// ex>
// 쉘 정렬의 예
// 쉘 정렬은 일정한 간격에 있는 항목들간 비교가 이루어져야 하며 이때 간격을 정하는
// 방식으로 다음과 같은 세가지 정도를 생각할 수 있습니다.
// 1) 전체 데이터의 개수를 2로 나누어가며 간격을 정하는 방법
//    데이터 개수 12
//    1회전-> 12/2 = 6 (6만큼 떨어진 항목들간 삽입 정렬을 시행함)
//    2회전-> 6/2 = 3
//    3회전-> 3/2 = 1
// 2) Knuth의 개선된 알고리즘을 통해 간격을 정하는 방법
//    간격 h는 아래의 공식에 따라 구할 수 있습니다.
//    h = 3 * h + 1
//    h = {1, 4, 13. 40, 121, 363...}
//    실제 적용할 때에는 전체 데이터 개수보다 작은 수를 선택하여 간격이 1이 될때까지
//    좁혀가면서 삽입정렬을 수행합니다.
// 3) 임의로 간격을 정하는 방법
//    여기에는 Knuth알고리즘을 이용해서 쉘 정렬하는 과정을 알아보도록 하겠습니다.
//	19	13	05	27	01	26	31	16	02	09	11	21
//
// ~~@..@~~ 쉘정렬은 조금 더 확인이 필요

void SelectionSort(int data[], int n);
void BubbleSort(int data[], int n);
void InsertionSort(int data[], int n);
void ShellSort(int data[], int n);
void PrintArray(int data[], int n);
void SortBasic();